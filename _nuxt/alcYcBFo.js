import{f as m,e as S}from"./BUPYE4wI.js";import{eN as g,eO as O,eP as x,eQ as D,ee as $,eb as F,eR as E,eS as q,eT as b,eU as T,ec as R,ed as G,eV as _,eW as v,cv as w,eX as L,dz as M,eY as C,eZ as H,e_ as U,e$ as k,f0 as j}from"./CpgQQs4L.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},n=new t.Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="129b86e0-40c3-4e8c-b1b2-9d2b6aad3398",t._sentryDebugIdIdentifier="sentry-dbid-129b86e0-40c3-4e8c-b1b2-9d2b6aad3398")}catch{}})();function B(t){const{abi:n,data:a}=t,s=g(a,0,4),e=n.find(o=>o.type==="function"&&s===O(x(o)));if(!e)throw new D(s,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:e.name,args:"inputs"in e&&e.inputs&&e.inputs.length>0?$(e.inputs,g(a,4)):void 0}}const p="/docs/contract/encodeErrorResult";function A(t){const{abi:n,errorName:a,args:s}=t;let e=n[0];if(a){const u=F({abi:n,args:s,name:a});if(!u)throw new E(a,{docsPath:p});e=u}if(e.type!=="error")throw new E(void 0,{docsPath:p});const o=x(e),r=O(o);let c="0x";if(s&&s.length>0){if(!e.inputs)throw new q(e.name,{docsPath:p});c=b(e.inputs,s)}return T([r,c])}const h="/docs/contract/encodeFunctionResult";function W(t){const{abi:n,functionName:a,result:s}=t;let e=n[0];if(a){const r=F({abi:n,name:a});if(!r)throw new R(a,{docsPath:h});e=r}if(e.type!=="function")throw new R(void 0,{docsPath:h});if(!e.outputs)throw new G(e.name,{docsPath:h});const o=(()=>{if(e.outputs.length===0)return[];if(e.outputs.length===1)return[s];if(Array.isArray(s))return s;throw new _(s)})();return b(e.outputs,o)}const N="x-batch-gateway:true";async function P(t){const{data:n,ccipRequest:a}=t,{args:[s]}=B({abi:m,data:n}),e=[],o=[];return await Promise.all(s.map(async(r,c)=>{try{o[c]=r.urls.includes(N)?await P({data:r.data,ccipRequest:a}):await a(r),e[c]=!1}catch(u){e[c]=!0,o[c]=z(u)}})),W({abi:m,functionName:"query",result:[e,o]})}function z(t){return t.name==="HttpRequestError"&&t.status?A({abi:m,errorName:"HttpError",args:[t.status,t.shortMessage]}):A({abi:[v],errorName:"Error",args:["shortMessage"in t?t.shortMessage:t.message]})}class J extends w{constructor({callbackSelector:n,cause:a,data:s,extraData:e,sender:o,urls:r}){var c;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],(c=a.metaMessages)!=null&&c.length?"":[],"Offchain Gateway Call:",r&&["  Gateway URL(s):",...r.map(u=>`    ${L(u)}`)],`  Sender: ${o}`,`  Data: ${s}`,`  Callback selector: ${n}`,`  Extra data: ${e}`].flat(),name:"OffchainLookupError"})}}class Q extends w{constructor({result:n,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${L(a)}`,`Response: ${M(n)}`],name:"OffchainLookupResponseMalformedError"})}}class V extends w{constructor({sender:n,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${n}`],name:"OffchainLookupSenderMismatchError"})}}const ee="0x556f1830",X={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function te(t,{blockNumber:n,blockTag:a,data:s,to:e}){const{args:o}=C({data:s,abi:[X]}),[r,c,u,f,d]=o,{ccipRead:i}=t,y=i&&typeof(i==null?void 0:i.request)=="function"?i.request:Y;try{if(!H(e,r))throw new V({sender:r,to:e});const l=c.includes(N)?await P({data:u,ccipRequest:y}):await y({data:u,sender:r,urls:c}),{data:I}=await S(t,{blockNumber:n,blockTag:a,data:U([f,b([{type:"bytes"},{type:"bytes"}],[l,d])]),to:e});return I}catch(l){throw new J({callbackSelector:f,cause:l,data:s,extraData:d,sender:r,urls:c})}}async function Y({data:t,sender:n,urls:a}){var e;let s=new Error("An unknown error occurred.");for(let o=0;o<a.length;o++){const r=a[o],c=r.includes("{data}")?"GET":"POST",u=c==="POST"?{data:t,sender:n}:void 0,f=c==="POST"?{"Content-Type":"application/json"}:{};try{const d=await fetch(r.replace("{sender}",n.toLowerCase()).replace("{data}",t),{body:JSON.stringify(u),headers:f,method:c});let i;if((e=d.headers.get("Content-Type"))!=null&&e.startsWith("application/json")?i=(await d.json()).data:i=await d.text(),!d.ok){s=new k({body:u,details:i!=null&&i.error?M(i.error):d.statusText,headers:d.headers,status:d.status,url:r});continue}if(!j(i)){s=new Q({result:i,url:r});continue}return i}catch(d){s=new k({body:u,details:d.message,url:r})}}throw s}export{Y as ccipRequest,te as offchainLookup,X as offchainLookupAbiItem,ee as offchainLookupSignature};
