{"version":3,"file":"Cp2hUfLz.js","sources":["../../../../node_modules/csv-parse/lib/api/CsvError.js","../../../../node_modules/csv-parse/lib/utils/is_object.js","../../../../node_modules/csv-parse/lib/api/normalize_columns_array.js","../../../../node_modules/csv-parse/lib/utils/ResizeableBuffer.js","../../../../node_modules/csv-parse/lib/api/init_state.js","../../../../node_modules/csv-parse/lib/utils/underscore.js","../../../../node_modules/csv-parse/lib/api/normalize_options.js","../../../../node_modules/csv-parse/lib/api/index.js","../../../../node_modules/csv-parse/lib/sync.js"],"sourcesContent":["\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ').trim();\n    super(message);\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nexport {CsvError};\n","\nconst is_object = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));\n};\n\nexport {is_object};\n","\nimport {CsvError} from './CsvError.js';\nimport {is_object} from '../utils/is_object.js';\n\nconst normalize_columns_array = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i];\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true };\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column };\n    }else if(is_object(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ]);\n      }\n      normalizedColumns[i] = column;\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ]);\n    }\n  }\n  return normalizedColumns;\n};\n\nexport {normalize_columns_array};\n","\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size;\n    this.length = 0;\n    this.buf = Buffer.allocUnsafe(size);\n  }\n  prepend(val){\n    if(Buffer.isBuffer(val)){\n      const length = this.length + val.length;\n      if(length >= this.size){\n        this.resize();\n        if(length >= this.size){\n          throw Error('INVALID_BUFFER_STATE');\n        }\n      }\n      const buf = this.buf;\n      this.buf = Buffer.allocUnsafe(this.size);\n      val.copy(this.buf, 0);\n      buf.copy(this.buf, val.length);\n      this.length += val.length;\n    }else{\n      const length = this.length++;\n      if(length === this.size){\n        this.resize();\n      }\n      const buf = this.clone();\n      this.buf[0] = val;\n      buf.copy(this.buf,1, 0, length);\n    }\n  }\n  append(val){\n    const length = this.length++;\n    if(length === this.size){\n      this.resize();\n    }\n    this.buf[length] = val;\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length));\n  }\n  resize(){\n    const length = this.length;\n    this.size = this.size * 2;\n    const buf = Buffer.allocUnsafe(this.size);\n    this.buf.copy(buf,0, 0, length);\n    this.buf = buf;\n  }\n  toString(encoding){\n    if(encoding){\n      return this.buf.slice(0, this.length).toString(encoding);\n    }else{\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n    }\n  }\n  toJSON(){\n    return this.toString('utf8');\n  }\n  reset(){\n    this.length = 0;\n  }\n}\n\nexport default ResizeableBuffer;\n","\nimport ResizeableBuffer from '../utils/ResizeableBuffer.js';\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst np = 12;\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadÃ©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\nconst space = 32;\nconst tab = 9;\n\nconst init_state = function(options){\n  return {\n    bomSkipped: false,\n    bufBytesStart: 0,\n    castField: options.cast_function,\n    commenting: false,\n    // Current error encountered by a record\n    error: undefined,\n    enabled: options.from_line === 1,\n    escaping: false,\n    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n    // columns can be `false`, `true`, `Array`\n    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n    field: new ResizeableBuffer(20),\n    firstLineToHeaders: options.cast_first_line_to_header,\n    needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map((delimiter) => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0,\n    ),\n    previousBuf: undefined,\n    quoting: false,\n    stop: false,\n    rawBuffer: new ResizeableBuffer(100),\n    record: [],\n    recordHasError: false,\n    record_length: 0,\n    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),\n    trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n    wasQuoting: false,\n    wasRowDelimiter: false,\n    timchars: [\n      Buffer.from(Buffer.from([cr], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([nl], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding),\n    ]\n  };\n};\n\nexport {init_state};\n","\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase();\n  });\n};\n\nexport {underscore};\n","\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {CsvError} from './CsvError.js';\nimport {underscore} from '../utils/underscore.js';\n\nconst normalize_options = function(opts){\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if(options.encoding === undefined || options.encoding === true){\n    options.encoding = 'utf8';\n  }else if(options.encoding === null || options.encoding === false){\n    options.encoding = null;\n  }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n    throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n      'Invalid option encoding:',\n      'encoding must be a string or null to return a buffer,',\n      `got ${JSON.stringify(options.encoding)}`\n    ], options);\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    throw new CsvError('CSV_INVALID_OPTION_BOM', [\n      'Invalid option bom:', 'bom must be true,',\n      `got ${JSON.stringify(options.bom)}`\n    ], options);\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n    options.cast = undefined;\n  }else if(typeof options.cast === 'function'){\n    options.cast_function = options.cast;\n    options.cast = true;\n  }else if(options.cast !== true){\n    throw new CsvError('CSV_INVALID_OPTION_CAST', [\n      'Invalid option cast:', 'cast must be true or a function,',\n      `got ${JSON.stringify(options.cast)}`\n    ], options);\n  }\n  // Normalize option `cast_date`\n  if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n    options.cast_date = false;\n  }else if(options.cast_date === true){\n    options.cast_date = function(value){\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  }else if (typeof options.cast_date !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n      'Invalid option cast_date:', 'cast_date must be true or a function,',\n      `got ${JSON.stringify(options.cast_date)}`\n    ], options);\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if(options.columns === true){\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  }else if(typeof options.columns === 'function'){\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  }else if(Array.isArray(options.columns)){\n    options.columns = normalize_columns_array(options.columns);\n  }else if(options.columns === undefined || options.columns === null || options.columns === false){\n    options.columns = false;\n  }else{\n    throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n      'Invalid option columns:',\n      'expect an array, a function or true,',\n      `got ${JSON.stringify(options.columns)}`\n    ], options);\n  }\n  // Normalize option `group_columns_by_name`\n  if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){\n    options.group_columns_by_name = false;\n  }else if(options.group_columns_by_name !== true){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'expect an boolean,',\n      `got ${JSON.stringify(options.group_columns_by_name)}`\n    ], options);\n  }else if(options.columns === false){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'the `columns` mode must be activated.'\n    ], options);\n  }\n  // Normalize option `comment`\n  if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n    options.comment = null;\n  }else{\n    if(typeof options.comment === 'string'){\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.comment)){\n      throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n        'Invalid option comment:',\n        'comment must be a buffer or a string,',\n        `got ${JSON.stringify(options.comment)}`\n      ], options);\n    }\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n  if(options.delimiter.length === 0){\n    throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n      'Invalid option delimiter:',\n      'delimiter must be a non empty string or buffer or array of string|buffer,',\n      `got ${delimiter_json}`\n    ], options);\n  }\n  options.delimiter = options.delimiter.map(function(delimiter){\n    if(delimiter === undefined || delimiter === null || delimiter === false){\n      return Buffer.from(',', options.encoding);\n    }\n    if(typeof delimiter === 'string'){\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if(!Buffer.isBuffer(delimiter) || delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options);\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === true){\n    options.escape = Buffer.from('\"', options.encoding);\n  }else if(typeof options.escape === 'string'){\n    options.escape = Buffer.from(options.escape, options.encoding);\n  }else if (options.escape === null || options.escape === false){\n    options.escape = null;\n  }\n  if(options.escape !== null){\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  }\n  // Normalize option `from`\n  if(options.from === undefined || options.from === null){\n    options.from = 1;\n  }else{\n    if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n      options.from = parseInt(options.from);\n    }\n    if(Number.isInteger(options.from)){\n      if(options.from < 0){\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  }\n  // Normalize option `from_line`\n  if(options.from_line === undefined || options.from_line === null){\n    options.from_line = 1;\n  }else{\n    if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n      options.from_line = parseInt(options.from_line);\n    }\n    if(Number.isInteger(options.from_line)){\n      if(options.from_line <= 0){\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n    options.ignore_last_delimiters = false;\n  }else if(typeof options.ignore_last_delimiters === 'number'){\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if(options.ignore_last_delimiters === 0){\n      options.ignore_last_delimiters = false;\n    }\n  }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n    throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n      'Invalid option `ignore_last_delimiters`:',\n      'the value must be a boolean value or an integer,',\n      `got ${JSON.stringify(options.ignore_last_delimiters)}`\n    ], options);\n  }\n  if(options.ignore_last_delimiters === true && options.columns === false){\n    throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n      'The option `ignore_last_delimiters`',\n      'requires the activation of the `columns` option'\n    ], options);\n  }\n  // Normalize option `info`\n  if(options.info === undefined || options.info === null || options.info === false){\n    options.info = false;\n  }else if(options.info !== true){\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  }\n  // Normalize option `max_record_size`\n  if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n    options.max_record_size = 0;\n  }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n    // Great, nothing to do\n  }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n    options.max_record_size = parseInt(options.max_record_size);\n  }else{\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  }\n  // Normalize option `objname`\n  if(options.objname === undefined || options.objname === null || options.objname === false){\n    options.objname = undefined;\n  }else if(Buffer.isBuffer(options.objname)){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if(options.encoding === null){\n      // Don't call `toString`, leave objname as a buffer\n    }else{\n      options.objname = options.objname.toString(options.encoding);\n    }\n  }else if(typeof options.objname === 'string'){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  }else if(typeof options.objname === 'number'){\n    // if(options.objname.length === 0){\n    //   throw new Error(`Invalid Option: objname must be a non empty string`);\n    // }\n    // Great, nothing to do\n  }else{\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n  if(options.objname !== undefined){\n    if(typeof options.objname === 'number'){\n      if(options.columns !== false){\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    }else{ // A string or a buffer\n      if(options.columns === false){\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if(options.on_record === undefined || options.on_record === null){\n    options.on_record = undefined;\n  }else if(typeof options.on_record !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n      'Invalid option `on_record`:',\n      'expect a function,',\n      `got ${JSON.stringify(options.on_record)}`\n    ], options);\n  }\n  // Normalize option `quote`\n  if(options.quote === null || options.quote === false || options.quote === ''){\n    options.quote = null;\n  }else{\n    if(options.quote === undefined || options.quote === true){\n      options.quote = Buffer.from('\"', options.encoding);\n    }else if(typeof options.quote === 'string'){\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.quote)){\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  }\n  // Normalize option `raw`\n  if(options.raw === undefined || options.raw === null || options.raw === false){\n    options.raw = false;\n  }else if(options.raw !== true){\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined){\n    options.record_delimiter = [];\n  }else if(typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)){\n    if(options.record_delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer,',\n        `got ${JSON.stringify(options.record_delimiter)}`\n      ], options);\n    }\n    options.record_delimiter = [options.record_delimiter];\n  }else if(!Array.isArray(options.record_delimiter)){\n    throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n      'Invalid option `record_delimiter`:',\n      'value must be a string, a buffer or array of string|buffer,',\n      `got ${JSON.stringify(options.record_delimiter)}`\n    ], options);\n  }\n  options.record_delimiter = options.record_delimiter.map(function(rd, i){\n    if(typeof rd !== 'string' && ! Buffer.isBuffer(rd)){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a string, a buffer or array of string|buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }else if(rd.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }\n    if(typeof rd === 'string'){\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if(typeof options.relax_column_count === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n    options.relax_column_count = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n  if(typeof options.relax_column_count_less === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n    options.relax_column_count_less = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n  if(typeof options.relax_column_count_more === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n    options.relax_column_count_more = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  }\n  // Normalize option `relax_quotes`\n  if(typeof options.relax_quotes === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_quotes === undefined || options.relax_quotes === null){\n    options.relax_quotes = false;\n  }else{\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  }\n  // Normalize option `skip_empty_lines`\n  if(typeof options.skip_empty_lines === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n    options.skip_empty_lines = false;\n  }else{\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if(typeof options.skip_records_with_empty_values === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){\n    options.skip_records_with_empty_values = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  }\n  // Normalize option `skip_records_with_error`\n  if(typeof options.skip_records_with_error === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){\n    options.skip_records_with_error = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  }\n  // Normalize option `rtrim`\n  if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n    options.rtrim = false;\n  }else if(options.rtrim !== true){\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  }\n  // Normalize option `ltrim`\n  if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n    options.ltrim = false;\n  }else if(options.ltrim !== true){\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  }\n  // Normalize option `trim`\n  if(options.trim === undefined || options.trim === null || options.trim === false){\n    options.trim = false;\n  }else if(options.trim !== true){\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if(options.trim === true && opts.ltrim !== false){\n    options.ltrim = true;\n  }else if(options.ltrim !== true){\n    options.ltrim = false;\n  }\n  if(options.trim === true && opts.rtrim !== false){\n    options.rtrim = true;\n  }else if(options.rtrim !== true){\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if(options.to === undefined || options.to === null){\n    options.to = -1;\n  }else{\n    if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n      options.to = parseInt(options.to);\n    }\n    if(Number.isInteger(options.to)){\n      if(options.to <= 0){\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  }\n  // Normalize option `to_line`\n  if(options.to_line === undefined || options.to_line === null){\n    options.to_line = -1;\n  }else{\n    if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n      options.to_line = parseInt(options.to_line);\n    }\n    if(Number.isInteger(options.to_line)){\n      if(options.to_line <= 0){\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n  return options;\n};\n\nexport {normalize_options};\n","\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadÃ©cimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n","\nimport {CsvError, transform} from './api/index.js';\n\nconst parse = function(data, opts={}){\n  if(typeof data === 'string'){\n    data = Buffer.from(data);\n  }\n  const records = opts && opts.objname ? {} : [];\n  const parser = transform(opts);\n  const push = (record) => {\n    if(parser.options.objname === undefined)\n      records.push(record);\n    else{\n      records[record[0]] = record[1];\n    }\n  };\n  const close = () => {};\n  const err1 = parser.parse(data, false, push, close);\n  if(err1 !== undefined) throw err1;\n  const err2 = parser.parse(undefined, true, push, close);\n  if(err2 !== undefined) throw err2;\n  return records;\n};\n\n// export default parse\nexport { parse };\nexport { CsvError };\n"],"names":["e","n","CsvError","code","message","options","contexts","context","key","value","is_object","obj","normalize_columns_array","columns","normalizedColumns","i","l","column","ResizeableBuffer","size","val","length","buf","encoding","np","cr","nl","space","tab","init_state","delimiter","v","underscore","str","_","match","normalize_options","opts","opt","date","delimiter_json","rd","isRecordEmpty","record","field","boms","transform","original_options","info","bufLen","end","escape","quote","quoting","needMoreDataSize","recordDelimiterMaxLength","numOfCharLeft","requiredLength","nextBuf","push","close","bom","from_line","ltrim","max_record_size","raw","relax_quotes","rtrim","skip_empty_lines","to","to_line","comment","record_delimiter","bomSkipped","previousBuf","rawBuffer","escapeIsQuote","bomLength","pos","chr","nextChr","isNextChrTrimable","isNextChrComment","isNextChrDelimiter","isNextChrRecordDelimiter","err","b","recordDelimiterLength","errField","errRecord","delimiterLength","lappend","rappend","group_columns_by_name","from","relax_column_count","relax_column_count_less","relax_column_count_more","skip_records_with_empty_values","enabled","recordLength","finalErr","objname","extRecord","firstLineToHeaders","headers","normalizedHeaders","cast","wasQuoting","f","on_record","timchars","loop1","timchar","j","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","ignore_last_delimiters","del","rdLength","rds","loop","msg","skip_records_with_error","isColumns","parse","data","records","parser","err1","err2"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8]}