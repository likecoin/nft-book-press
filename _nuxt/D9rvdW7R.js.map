{"version":3,"file":"D9rvdW7R.js","sources":["../../../../node_modules/viem/_esm/utils/promise/withCache.js","../../../../node_modules/viem/_esm/actions/public/getBlockNumber.js","../../../../node_modules/viem/_esm/actions/public/getTransaction.js","../../../../node_modules/viem/_esm/actions/public/getTransactionReceipt.js","../../../../node_modules/viem/_esm/utils/observe.js","../../../../node_modules/viem/_esm/utils/poll.js","../../../../node_modules/viem/_esm/actions/public/watchBlockNumber.js","../../../../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js","../../../../node_modules/@wagmi/core/dist/esm/actions/waitForTransactionReceipt.js","../../../../node_modules/@wagmi/core/dist/esm/actions/writeContract.js","../../../../node_modules/@wagmi/core/dist/esm/query/writeContract.js","../../../../node_modules/@wagmi/vue/dist/esm/composables/useWriteContract.js","../../../../utils/evm.ts"],"sourcesContent":["/** @internal */\nexport const promiseCache = /*#__PURE__*/ new Map();\n/** @internal */\nexport const responseCache = /*#__PURE__*/ new Map();\nexport function getCache(cacheKey) {\n    const buildCache = (cacheKey, cache) => ({\n        clear: () => cache.delete(cacheKey),\n        get: () => cache.get(cacheKey),\n        set: (data) => cache.set(cacheKey, data),\n    });\n    const promise = buildCache(cacheKey, promiseCache);\n    const response = buildCache(cacheKey, responseCache);\n    return {\n        clear: () => {\n            promise.clear();\n            response.clear();\n        },\n        promise,\n        response,\n    };\n}\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {\n    const cache = getCache(cacheKey);\n    // If a response exists in the cache, and it's not expired, return it\n    // and do not invoke the promise.\n    // If the max age is 0, the cache is disabled.\n    const response = cache.response.get();\n    if (response && cacheTime > 0) {\n        const age = new Date().getTime() - response.created.getTime();\n        if (age < cacheTime)\n            return response.data;\n    }\n    let promise = cache.promise.get();\n    if (!promise) {\n        promise = fn();\n        // Store the promise in the cache so that subsequent invocations\n        // will wait for the same promise to resolve (deduping).\n        cache.promise.set(promise);\n    }\n    try {\n        const data = await promise;\n        // Store the response in the cache so that subsequent invocations\n        // will return the same response.\n        cache.response.set({ created: new Date(), data });\n        return data;\n    }\n    finally {\n        // Clear the promise cache so that subsequent invocations will\n        // invoke the promise again.\n        cache.promise.clear();\n    }\n}\n//# sourceMappingURL=withCache.js.map","import { getCache, withCache, } from '../../utils/promise/withCache.js';\nconst cacheKey = (id) => `blockNumber.${id}`;\n/** @internal */\nexport function getBlockNumberCache(id) {\n    return getCache(cacheKey(id));\n}\n/**\n * Returns the number of the most recent block seen.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockNumberParameters}\n * @returns The number of the block. {@link GetBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockNumber } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blockNumber = await getBlockNumber(client)\n * // 69420n\n */\nexport async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {\n    const blockNumberHex = await withCache(() => client.request({\n        method: 'eth_blockNumber',\n    }), { cacheKey: cacheKey(client.uid), cacheTime });\n    return BigInt(blockNumberHex);\n}\n//# sourceMappingURL=getBlockNumber.js.map","import { TransactionNotFoundError, } from '../../errors/transaction.js';\nimport { numberToHex, } from '../../utils/encoding/toHex.js';\nimport { formatTransaction, } from '../../utils/formatters/transaction.js';\n/**\n * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms#transaction) given a hash or block identifier.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransaction\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionParameters}\n * @returns The transaction information. {@link GetTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transaction = await getTransaction(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index, }) {\n    const blockTag = blockTag_ || 'latest';\n    const blockNumberHex = blockNumber !== undefined ? numberToHex(blockNumber) : undefined;\n    let transaction = null;\n    if (hash) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByHash',\n            params: [hash],\n        }, { dedupe: true });\n    }\n    else if (blockHash) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByBlockHashAndIndex',\n            params: [blockHash, numberToHex(index)],\n        }, { dedupe: true });\n    }\n    else if (blockNumberHex || blockTag) {\n        transaction = await client.request({\n            method: 'eth_getTransactionByBlockNumberAndIndex',\n            params: [blockNumberHex || blockTag, numberToHex(index)],\n        }, { dedupe: Boolean(blockNumberHex) });\n    }\n    if (!transaction)\n        throw new TransactionNotFoundError({\n            blockHash,\n            blockNumber,\n            blockTag,\n            hash,\n            index,\n        });\n    const format = client.chain?.formatters?.transaction?.format || formatTransaction;\n    return format(transaction);\n}\n//# sourceMappingURL=getTransaction.js.map","import { TransactionReceiptNotFoundError, } from '../../errors/transaction.js';\nimport { formatTransactionReceipt, } from '../../utils/formatters/transactionReceipt.js';\n/**\n * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionReceiptParameters}\n * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionReceipt } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await getTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionReceipt(client, { hash }) {\n    const receipt = await client.request({\n        method: 'eth_getTransactionReceipt',\n        params: [hash],\n    }, { dedupe: true });\n    if (!receipt)\n        throw new TransactionReceiptNotFoundError({ hash });\n    const format = client.chain?.formatters?.transactionReceipt?.format ||\n        formatTransactionReceipt;\n    return format(receipt);\n}\n//# sourceMappingURL=getTransactionReceipt.js.map","/** @internal */\nexport const listenersCache = /*#__PURE__*/ new Map();\n/** @internal */\nexport const cleanupCache = /*#__PURE__*/ new Map();\nlet callbackCount = 0;\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe(observerId, callbacks, fn) {\n    const callbackId = ++callbackCount;\n    const getListeners = () => listenersCache.get(observerId) || [];\n    const unsubscribe = () => {\n        const listeners = getListeners();\n        listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));\n    };\n    const unwatch = () => {\n        const listeners = getListeners();\n        if (!listeners.some((cb) => cb.id === callbackId))\n            return;\n        const cleanup = cleanupCache.get(observerId);\n        if (listeners.length === 1 && cleanup)\n            cleanup();\n        unsubscribe();\n    };\n    const listeners = getListeners();\n    listenersCache.set(observerId, [\n        ...listeners,\n        { id: callbackId, fns: callbacks },\n    ]);\n    if (listeners && listeners.length > 0)\n        return unwatch;\n    const emit = {};\n    for (const key in callbacks) {\n        emit[key] = ((...args) => {\n            const listeners = getListeners();\n            if (listeners.length === 0)\n                return;\n            for (const listener of listeners)\n                listener.fns[key]?.(...args);\n        });\n    }\n    const cleanup = fn(emit);\n    if (typeof cleanup === 'function')\n        cleanupCache.set(observerId, cleanup);\n    return unwatch;\n}\n//# sourceMappingURL=observe.js.map","import { wait } from './wait.js';\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll(fn, { emitOnBegin, initialWaitTime, interval }) {\n    let active = true;\n    const unwatch = () => (active = false);\n    const watch = async () => {\n        let data = undefined;\n        if (emitOnBegin)\n            data = await fn({ unpoll: unwatch });\n        const initialWait = (await initialWaitTime?.(data)) ?? interval;\n        await wait(initialWait);\n        const poll = async () => {\n            if (!active)\n                return;\n            await fn({ unpoll: unwatch });\n            await wait(interval);\n            poll();\n        };\n        poll();\n    };\n    watch();\n    return unwatch;\n}\n//# sourceMappingURL=poll.js.map","import { hexToBigInt } from '../../utils/encoding/fromHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { poll } from '../../utils/poll.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlockNumber, } from './getBlockNumber.js';\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {\n    const enablePolling = (() => {\n        if (typeof poll_ !== 'undefined')\n            return poll_;\n        if (client.transport.type === 'webSocket')\n            return false;\n        if (client.transport.type === 'fallback' &&\n            client.transport.transports[0].config.type === 'webSocket')\n            return false;\n        return true;\n    })();\n    let prevBlockNumber;\n    const pollBlockNumber = () => {\n        const observerId = stringify([\n            'watchBlockNumber',\n            client.uid,\n            emitOnBegin,\n            emitMissed,\n            pollingInterval,\n        ]);\n        return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {\n            try {\n                const blockNumber = await getAction(client, getBlockNumber, 'getBlockNumber')({ cacheTime: 0 });\n                if (prevBlockNumber) {\n                    // If the current block number is the same as the previous,\n                    // we can skip.\n                    if (blockNumber === prevBlockNumber)\n                        return;\n                    // If we have missed out on some previous blocks, and the\n                    // `emitMissed` flag is truthy, let's emit those blocks.\n                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n                        for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                            emit.onBlockNumber(i, prevBlockNumber);\n                            prevBlockNumber = i;\n                        }\n                    }\n                }\n                // If the next block number is greater than the previous,\n                // it is not in the past, and we can emit the new block number.\n                if (!prevBlockNumber || blockNumber > prevBlockNumber) {\n                    emit.onBlockNumber(blockNumber, prevBlockNumber);\n                    prevBlockNumber = blockNumber;\n                }\n            }\n            catch (err) {\n                emit.onError?.(err);\n            }\n        }, {\n            emitOnBegin,\n            interval: pollingInterval,\n        }));\n    };\n    const subscribeBlockNumber = () => {\n        const observerId = stringify([\n            'watchBlockNumber',\n            client.uid,\n            emitOnBegin,\n            emitMissed,\n        ]);\n        return observe(observerId, { onBlockNumber, onError }, (emit) => {\n            let active = true;\n            let unsubscribe = () => (active = false);\n            (async () => {\n                try {\n                    const transport = (() => {\n                        if (client.transport.type === 'fallback') {\n                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket');\n                            if (!transport)\n                                return client.transport;\n                            return transport.value;\n                        }\n                        return client.transport;\n                    })();\n                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n                        params: ['newHeads'],\n                        onData(data) {\n                            if (!active)\n                                return;\n                            const blockNumber = hexToBigInt(data.result?.number);\n                            emit.onBlockNumber(blockNumber, prevBlockNumber);\n                            prevBlockNumber = blockNumber;\n                        },\n                        onError(error) {\n                            emit.onError?.(error);\n                        },\n                    });\n                    unsubscribe = unsubscribe_;\n                    if (!active)\n                        unsubscribe();\n                }\n                catch (err) {\n                    onError?.(err);\n                }\n            })();\n            return () => unsubscribe();\n        });\n    };\n    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\n}\n//# sourceMappingURL=watchBlockNumber.js.map","import { BlockNotFoundError } from '../../errors/block.js';\nimport { TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError, } from '../../errors/transaction.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { observe } from '../../utils/observe.js';\nimport { withResolvers } from '../../utils/promise/withResolvers.js';\nimport { withRetry, } from '../../utils/promise/withRetry.js';\nimport { stringify } from '../../utils/stringify.js';\nimport { getBlock } from './getBlock.js';\nimport { getTransaction, } from './getTransaction.js';\nimport { getTransactionReceipt, } from './getTransactionReceipt.js';\nimport { watchBlockNumber, } from './watchBlockNumber.js';\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, retryCount = 6, retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\ntimeout = 180_000, }) {\n    const observerId = stringify(['waitForTransactionReceipt', client.uid, hash]);\n    let transaction;\n    let replacedTransaction;\n    let receipt;\n    let retrying = false;\n    const { promise, resolve, reject } = withResolvers();\n    const timer = timeout\n        ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash })), timeout)\n        : undefined;\n    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {\n        const _unwatch = getAction(client, watchBlockNumber, 'watchBlockNumber')({\n            emitMissed: true,\n            emitOnBegin: true,\n            poll: true,\n            pollingInterval,\n            async onBlockNumber(blockNumber_) {\n                const done = (fn) => {\n                    clearTimeout(timer);\n                    _unwatch();\n                    fn();\n                    _unobserve();\n                };\n                let blockNumber = blockNumber_;\n                if (retrying)\n                    return;\n                try {\n                    // If we already have a valid receipt, let's check if we have enough\n                    // confirmations. If we do, then we can resolve.\n                    if (receipt) {\n                        if (confirmations > 1 &&\n                            (!receipt.blockNumber ||\n                                blockNumber - receipt.blockNumber + 1n < confirmations))\n                            return;\n                        done(() => emit.resolve(receipt));\n                        return;\n                    }\n                    // Get the transaction to check if it's been replaced.\n                    // We need to retry as some RPC Providers may be slow to sync\n                    // up mined transactions.\n                    if (!transaction) {\n                        retrying = true;\n                        await withRetry(async () => {\n                            transaction = (await getAction(client, getTransaction, 'getTransaction')({ hash }));\n                            if (transaction.blockNumber)\n                                blockNumber = transaction.blockNumber;\n                        }, {\n                            delay: retryDelay,\n                            retryCount,\n                        });\n                        retrying = false;\n                    }\n                    // Get the receipt to check if it's been processed.\n                    receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({ hash });\n                    // Check if we have enough confirmations. If not, continue polling.\n                    if (confirmations > 1 &&\n                        (!receipt.blockNumber ||\n                            blockNumber - receipt.blockNumber + 1n < confirmations))\n                        return;\n                    done(() => emit.resolve(receipt));\n                }\n                catch (err) {\n                    // If the receipt is not found, the transaction will be pending.\n                    // We need to check if it has potentially been replaced.\n                    if (err instanceof TransactionNotFoundError ||\n                        err instanceof TransactionReceiptNotFoundError) {\n                        if (!transaction) {\n                            retrying = false;\n                            return;\n                        }\n                        try {\n                            replacedTransaction = transaction;\n                            // Let's retrieve the transactions from the current block.\n                            // We need to retry as some RPC Providers may be slow to sync\n                            // up mined blocks.\n                            retrying = true;\n                            const block = await withRetry(() => getAction(client, getBlock, 'getBlock')({\n                                blockNumber,\n                                includeTransactions: true,\n                            }), {\n                                delay: retryDelay,\n                                retryCount,\n                                shouldRetry: ({ error }) => error instanceof BlockNotFoundError,\n                            });\n                            retrying = false;\n                            const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&\n                                nonce === replacedTransaction.nonce);\n                            // If we couldn't find a replacement transaction, continue polling.\n                            if (!replacementTransaction)\n                                return;\n                            // If we found a replacement transaction, return it's receipt.\n                            receipt = await getAction(client, getTransactionReceipt, 'getTransactionReceipt')({\n                                hash: replacementTransaction.hash,\n                            });\n                            // Check if we have enough confirmations. If not, continue polling.\n                            if (confirmations > 1 &&\n                                (!receipt.blockNumber ||\n                                    blockNumber - receipt.blockNumber + 1n < confirmations))\n                                return;\n                            let reason = 'replaced';\n                            if (replacementTransaction.to === replacedTransaction.to &&\n                                replacementTransaction.value === replacedTransaction.value &&\n                                replacementTransaction.input === replacedTransaction.input) {\n                                reason = 'repriced';\n                            }\n                            else if (replacementTransaction.from === replacementTransaction.to &&\n                                replacementTransaction.value === 0n) {\n                                reason = 'cancelled';\n                            }\n                            done(() => {\n                                emit.onReplaced?.({\n                                    reason,\n                                    replacedTransaction: replacedTransaction,\n                                    transaction: replacementTransaction,\n                                    transactionReceipt: receipt,\n                                });\n                                emit.resolve(receipt);\n                            });\n                        }\n                        catch (err_) {\n                            done(() => emit.reject(err_));\n                        }\n                    }\n                    else {\n                        done(() => emit.reject(err));\n                    }\n                }\n            },\n        });\n    });\n    return promise;\n}\n//# sourceMappingURL=waitForTransactionReceipt.js.map","import { hexToString } from 'viem';\nimport { call, getTransaction, waitForTransactionReceipt as viem_waitForTransactionReceipt, } from 'viem/actions';\nimport { getAction } from '../utils/getAction.js';\nexport async function waitForTransactionReceipt(config, parameters) {\n    const { chainId, timeout = 0, ...rest } = parameters;\n    const client = config.getClient({ chainId });\n    const action = getAction(client, viem_waitForTransactionReceipt, 'waitForTransactionReceipt');\n    const receipt = await action({ ...rest, timeout });\n    if (receipt.status === 'reverted') {\n        const action_getTransaction = getAction(client, getTransaction, 'getTransaction');\n        const txn = await action_getTransaction({ hash: receipt.transactionHash });\n        const action_call = getAction(client, call, 'call');\n        const code = await action_call({\n            ...txn,\n            data: txn.input,\n            gasPrice: txn.type !== 'eip1559' ? txn.gasPrice : undefined,\n            maxFeePerGas: txn.type === 'eip1559' ? txn.maxFeePerGas : undefined,\n            maxPriorityFeePerGas: txn.type === 'eip1559' ? txn.maxPriorityFeePerGas : undefined,\n        });\n        const reason = code?.data\n            ? hexToString(`0x${code.data.substring(138)}`)\n            : 'unknown reason';\n        throw new Error(reason);\n    }\n    return {\n        ...receipt,\n        chainId: client.chain.id,\n    };\n}\n//# sourceMappingURL=waitForTransactionReceipt.js.map","import { writeContract as viem_writeContract, } from 'viem/actions';\nimport { getAction } from '../utils/getAction.js';\nimport { getConnectorClient, } from './getConnectorClient.js';\n/** https://wagmi.sh/core/api/actions/writeContract */\nexport async function writeContract(config, parameters) {\n    const { account, chainId, connector, ...request } = parameters;\n    let client;\n    if (typeof account === 'object' && account?.type === 'local')\n        client = config.getClient({ chainId });\n    else\n        client = await getConnectorClient(config, {\n            account: account ?? undefined,\n            chainId,\n            connector,\n        });\n    const action = getAction(client, viem_writeContract, 'writeContract');\n    const hash = await action({\n        ...request,\n        ...(account ? { account } : {}),\n        chain: chainId ? { id: chainId } : null,\n    });\n    return hash;\n}\n//# sourceMappingURL=writeContract.js.map","import { writeContract, } from '../actions/writeContract.js';\nexport function writeContractMutationOptions(config) {\n    return {\n        mutationFn(variables) {\n            return writeContract(config, variables);\n        },\n        mutationKey: ['writeContract'],\n    };\n}\n//# sourceMappingURL=writeContract.js.map","import { useMutation } from '@tanstack/vue-query';\nimport { writeContractMutationOptions, } from '@wagmi/core/query';\nimport { useConfig } from './useConfig.js';\n/** https://wagmi.sh/vue/api/composables/useWriteContract */\nexport function useWriteContract(parameters = {}) {\n    const { mutation } = parameters;\n    const config = useConfig(parameters);\n    const mutationOptions = writeContractMutationOptions(config);\n    const { mutate, mutateAsync, ...result } = useMutation({\n        ...mutation,\n        ...mutationOptions,\n    });\n    return {\n        ...result,\n        writeContract: mutate,\n        writeContractAsync: mutateAsync,\n    };\n}\n//# sourceMappingURL=useWriteContract.js.map","import { waitForTransactionReceipt as wagmiWaitForTransactionReceipt } from '@wagmi/vue/actions'\n\nexport async function waitForTransactionReceipt (\n  config: Parameters<typeof wagmiWaitForTransactionReceipt>[0],\n  parameters: Parameters<typeof wagmiWaitForTransactionReceipt>[1]\n) {\n  let receipt\n  try {\n    receipt = await wagmiWaitForTransactionReceipt(config, parameters)\n  } catch (error) {\n    // Sometimes a TransactionReceiptNotFoundError would be thrown\n    // https://github.com/wevm/viem/issues/1056\n    await sleep(3000)\n    receipt = await wagmiWaitForTransactionReceipt(config, parameters)\n  }\n  return receipt\n}\n"],"names":["promiseCache","responseCache","getCache","cacheKey","buildCache","cache","data","promise","response","withCache","fn","cacheTime","id","getBlockNumber","client","blockNumberHex","getTransaction","blockHash","blockNumber","blockTag_","hash","index","blockTag","numberToHex","transaction","TransactionNotFoundError","_c","_b","_a","formatTransaction","getTransactionReceipt","receipt","TransactionReceiptNotFoundError","formatTransactionReceipt","listenersCache","cleanupCache","callbackCount","observe","observerId","callbacks","callbackId","getListeners","unsubscribe","listeners","cb","unwatch","cleanup","emit","key","args","listener","poll","emitOnBegin","initialWaitTime","interval","active","initialWait","wait","watchBlockNumber","emitMissed","onBlockNumber","onError","poll_","pollingInterval","enablePolling","prevBlockNumber","stringify","getAction","i","err","transport","unsubscribe_","hexToBigInt","error","waitForTransactionReceipt","confirmations","onReplaced","retryCount","retryDelay","count","timeout","replacedTransaction","retrying","resolve","reject","withResolvers","timer","WaitForTransactionReceiptTimeoutError","_unobserve","_unwatch","blockNumber_","done","withRetry","block","getBlock","BlockNotFoundError","replacementTransaction","from","nonce","reason","err_","config","parameters","chainId","rest","viem_waitForTransactionReceipt","txn","code","call","hexToString","writeContract","account","connector","request","getConnectorClient","viem_writeContract","writeContractMutationOptions","variables","useWriteContract","mutation","useConfig","mutationOptions","mutate","mutateAsync","result","useMutation","wagmiWaitForTransactionReceipt","sleep"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}