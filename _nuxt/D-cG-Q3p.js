import{f3 as xt,eJ as jt,eK as ct,e$ as st,eM as F,fc as re,f6 as oe,fd as ie,eI as se,fe as qt,f8 as ae,e_ as fe,fa as ce}from"./BHFTF29u.js";(function(){try{var t=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},n=new t.Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="7e9dfbd8-16e5-4dfc-a116-f7af0d78ac77",t._sentryDebugIdIdentifier="sentry-dbid-7e9dfbd8-16e5-4dfc-a116-f7af0d78ac77")}catch{}})();/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt(0),ut=BigInt(1);function lt(t,n){if(typeof n!="boolean")throw new Error(t+" boolean expected, got "+n)}function at(t){const n=t.toString(16);return n.length&1?"0"+n:n}function kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?St:BigInt("0x"+t)}function ht(t){return kt(st(t))}function Ut(t){return ct(t),kt(st(Uint8Array.from(t).reverse()))}function It(t,n){return xt(t.toString(16).padStart(n*2,"0"))}function Ct(t,n){return It(t,n).reverse()}function $(t,n,e){let r;if(typeof n=="string")try{r=xt(n)}catch(i){throw new Error(t+" must be hex string or Uint8Array, cause: "+i)}else if(jt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(t+" of length "+e+" expected, got "+s);return r}const mt=t=>typeof t=="bigint"&&St<=t;function Mt(t,n,e){return mt(t)&&mt(n)&&mt(e)&&n<=t&&t<e}function ue(t,n,e,r){if(!Mt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function le(t){let n;for(n=0;t>St;t>>=ut,n+=1);return n}function $e(t,n){return t>>BigInt(n)&ut}const wt=t=>(ut<<BigInt(t))-ut;function de(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");const r=S=>new Uint8Array(S),s=S=>Uint8Array.of(S);let i=r(t),o=r(t),c=0;const u=()=>{i.fill(1),o.fill(0),c=0},g=(...S)=>e(o,i,...S),a=(S=r(0))=>{o=g(s(0),S),i=g(),S.length!==0&&(o=g(s(1),S),i=g())},E=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let S=0;const A=[];for(;S<n;){i=g();const _=i.slice();A.push(_),S+=i.length}return F(...A)};return(S,A)=>{u(),a(S);let _;for(;!(_=A(E()));)a();return u(),_}}function Ke(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function _t(t,n,e={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function r(s,i,o){const c=t[s];if(o&&c===void 0)return;const u=typeof c;if(u!==i||c===null)throw new Error(`param "${s}" is invalid: expected ${i}, got ${u}`)}Object.entries(n).forEach(([s,i])=>r(s,i,!1)),Object.entries(e).forEach(([s,i])=>r(s,i,!0))}const Ve=()=>{throw new Error("not implemented")};function At(t){const n=new WeakMap;return(e,...r)=>{const s=n.get(e);if(s!==void 0)return s;const i=t(e,...r);return n.set(e,i),i}}class $t extends re{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,oe(n);const r=ie(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?n.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=n.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),se(i)}update(n){return qt(this),this.iHash.update(n),this}digestInto(n){qt(this),ct(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:i,blockLen:o,outputLen:c}=this;return n=n,n.finished=s,n.destroyed=i,n.blockLen=o,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Kt=(t,n,e)=>new $t(t,n).update(e).digest();Kt.create=(t,n)=>new $t(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),Z=BigInt(1),G=BigInt(2),he=BigInt(3),Vt=BigInt(4),Yt=BigInt(5),Dt=BigInt(8);function U(t,n){const e=t%n;return e>=k?e:n+e}function M(t,n,e){let r=t;for(;n-- >k;)r*=r,r%=e;return r}function Ot(t,n){if(t===k)throw new Error("invert: expected non-zero number");if(n<=k)throw new Error("invert: expected positive modulus, got "+n);let e=U(t,n),r=n,s=k,i=Z;for(;e!==k;){const c=r/e,u=r%e,g=s-i*c;r=e,e=u,s=i,i=g}if(r!==Z)throw new Error("invert: does not exist");return U(s,n)}function Pt(t,n){const e=(t.ORDER+Z)/Vt,r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}function we(t,n){const e=(t.ORDER-Yt)/Dt,r=t.mul(n,G),s=t.pow(r,e),i=t.mul(n,s),o=t.mul(t.mul(i,G),s),c=t.mul(i,t.sub(o,t.ONE));if(!t.eql(t.sqr(c),n))throw new Error("Cannot find square root");return c}function ge(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let n=t-Z,e=0;for(;n%G===k;)n/=G,e++;let r=G;const s=gt(t);for(;Ht(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Pt;let i=s.pow(r,n);const o=(n+Z)/G;return function(u,g){if(u.is0(g))return g;if(Ht(u,g)!==1)throw new Error("Cannot find square root");let a=e,E=u.mul(u.ONE,i),x=u.pow(g,n),S=u.pow(g,o);for(;!u.eql(x,u.ONE);){if(u.is0(x))return u.ZERO;let A=1,_=u.sqr(x);for(;!u.eql(_,u.ONE);)if(A++,_=u.sqr(_),A===a)throw new Error("Cannot find square root");const L=Z<<BigInt(a-A-1),C=u.pow(E,L);a=A,E=u.sqr(C),x=u.mul(x,E),S=u.mul(S,C)}return S}}function ye(t){return t%Vt===he?Pt:t%Dt===Yt?we:ge(t)}const Ye=(t,n)=>(U(t,n)&Z)===Z,me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pe(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=me.reduce((r,s)=>(r[s]="function",r),n);return _t(t,e),t}function be(t,n,e){if(e<k)throw new Error("invalid exponent, negatives unsupported");if(e===k)return t.ONE;if(e===Z)return n;let r=t.ONE,s=n;for(;e>k;)e&Z&&(r=t.mul(r,s)),s=t.sqr(s),e>>=Z;return r}function Ft(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),s=n.reduce((o,c,u)=>t.is0(c)?o:(r[u]=o,t.mul(o,c)),t.ONE),i=t.inv(s);return n.reduceRight((o,c,u)=>t.is0(c)?o:(r[u]=t.mul(o,r[u]),t.mul(o,c)),i),r}function Ht(t,n){const e=(t.ORDER-Z)/G,r=t.pow(n,e),s=t.eql(r,t.ONE),i=t.eql(r,t.ZERO),o=t.eql(r,t.neg(t.ONE));if(!s&&!i&&!o)throw new Error("invalid Legendre symbol result");return s?1:i?0:-1}function Ee(t,n){n!==void 0&&ae(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function gt(t,n,e=!1,r={}){if(t<=k)throw new Error("invalid field: expected ORDER > 0, got "+t);let s,i;if(typeof n=="object"&&n!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const a=n;a.BITS&&(s=a.BITS),a.sqrt&&(i=a.sqrt),typeof a.isLE=="boolean"&&(e=a.isLE)}else typeof n=="number"&&(s=n),r.sqrt&&(i=r.sqrt);const{nBitLength:o,nByteLength:c}=Ee(t,s);if(c>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let u;const g=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:c,MASK:wt(o),ZERO:k,ONE:Z,create:a=>U(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return k<=a&&a<t},is0:a=>a===k,isValidNot0:a=>!g.is0(a)&&g.isValid(a),isOdd:a=>(a&Z)===Z,neg:a=>U(-a,t),eql:(a,E)=>a===E,sqr:a=>U(a*a,t),add:(a,E)=>U(a+E,t),sub:(a,E)=>U(a-E,t),mul:(a,E)=>U(a*E,t),pow:(a,E)=>be(g,a,E),div:(a,E)=>U(a*Ot(E,t),t),sqrN:a=>a*a,addN:(a,E)=>a+E,subN:(a,E)=>a-E,mulN:(a,E)=>a*E,inv:a=>Ot(a,t),sqrt:i||(a=>(u||(u=ye(t)),u(g,a))),toBytes:a=>e?Ct(a,c):It(a,c),fromBytes:a=>{if(a.length!==c)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+a.length);return e?Ut(a):ht(a)},invertBatch:a=>Ft(g,a),cmov:(a,E,x)=>x?E:a});return Object.freeze(g)}function Gt(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Xt(t){const n=Gt(t);return n+Math.ceil(n/2)}function Be(t,n,e=!1){const r=t.length,s=Gt(n),i=Xt(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const o=e?Ut(t):ht(t),c=U(o,n-Z)+Z;return e?Ct(c,s):It(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),X=BigInt(1);function ot(t,n){const e=n.negate();return t?e:n}function ve(t,n,e){const r=n==="pz"?o=>o.pz:o=>o.ez,s=Ft(t.Fp,e.map(r));return e.map((o,c)=>o.toAffine(s[c])).map(t.fromAffine)}function Wt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function pt(t,n){Wt(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),s=2**t,i=wt(t),o=BigInt(t);return{windows:e,windowSize:r,mask:i,maxNumber:s,shiftBy:o}}function Rt(t,n,e){const{windowSize:r,mask:s,maxNumber:i,shiftBy:o}=e;let c=Number(t&s),u=t>>o;c>r&&(c-=i,u+=X);const g=n*r,a=g+Math.abs(c)-1,E=c===0,x=c<0,S=n%2!==0;return{nextN:u,offset:a,isZero:E,isNeg:x,isNegF:S,offsetF:g}}function xe(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Se(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const bt=new WeakMap,Qt=new WeakMap;function Et(t){return Qt.get(t)||1}function zt(t){if(t!==nt)throw new Error("invalid wNAF")}function Ie(t,n){return{constTimeNegate:ot,hasPrecomputes(e){return Et(e)!==1},unsafeLadder(e,r,s=t.ZERO){let i=e;for(;r>nt;)r&X&&(s=s.add(i)),i=i.double(),r>>=X;return s},precomputeWindow(e,r){const{windows:s,windowSize:i}=pt(r,n),o=[];let c=e,u=c;for(let g=0;g<s;g++){u=c,o.push(u);for(let a=1;a<i;a++)u=u.add(c),o.push(u);c=u.double()}return o},wNAF(e,r,s){let i=t.ZERO,o=t.BASE;const c=pt(e,n);for(let u=0;u<c.windows;u++){const{nextN:g,offset:a,isZero:E,isNeg:x,isNegF:S,offsetF:A}=Rt(s,u,c);s=g,E?o=o.add(ot(S,r[A])):i=i.add(ot(x,r[a]))}return zt(s),{p:i,f:o}},wNAFUnsafe(e,r,s,i=t.ZERO){const o=pt(e,n);for(let c=0;c<o.windows&&s!==nt;c++){const{nextN:u,offset:g,isZero:a,isNeg:E}=Rt(s,c,o);if(s=u,!a){const x=r[g];i=i.add(E?x.negate():x)}}return zt(s),i},getPrecomputes(e,r,s){let i=bt.get(r);return i||(i=this.precomputeWindow(r,e),e!==1&&(typeof s=="function"&&(i=s(i)),bt.set(r,i))),i},wNAFCached(e,r,s){const i=Et(e);return this.wNAF(i,this.getPrecomputes(i,e,s),r)},wNAFCachedUnsafe(e,r,s,i){const o=Et(e);return o===1?this.unsafeLadder(e,r,i):this.wNAFUnsafe(o,this.getPrecomputes(o,e,s),r,i)},setWindowSize(e,r){Wt(r,n),Qt.set(e,r),bt.delete(e)}}}function _e(t,n,e,r){let s=n,i=t.ZERO,o=t.ZERO;for(;e>nt||r>nt;)e&X&&(i=i.add(s)),r&X&&(o=o.add(s)),s=s.double(),e>>=X,r>>=X;return{p1:i,p2:o}}function Ne(t,n,e,r){xe(e,t),Se(r,n);const s=e.length,i=r.length;if(s!==i)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,c=le(BigInt(s));let u=1;c>12?u=c-3:c>4?u=c-2:c>0&&(u=2);const g=wt(u),a=new Array(Number(g)+1).fill(o),E=Math.floor((n.BITS-1)/u)*u;let x=o;for(let S=E;S>=0;S-=u){a.fill(o);for(let _=0;_<i;_++){const L=r[_],C=Number(L>>BigInt(S)&g);a[C]=a[C].add(e[_])}let A=o;for(let _=a.length-1,L=o;_>0;_--)L=L.add(a[_]),A=A.add(L);if(x=x.add(A),S!==0)for(let _=0;_<u;_++)x=x.double()}return x}function Lt(t,n){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return pe(n),n}else return gt(t)}function qe(t,n,e={}){if(!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const c of["p","n","h"]){const u=n[c];if(!(typeof u=="bigint"&&u>nt))throw new Error(`CURVE.${c} must be positive bigint`)}const r=Lt(n.p,e.Fp),s=Lt(n.n,e.Fn),o=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(const c of o)if(!r.isValid(n[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Zt(t){t.lowS!==void 0&&lt("lowS",t.lowS),t.prehash!==void 0&&lt("prehash",t.prehash)}class Ae extends Error{constructor(n=""){super(n)}}const K={Err:Ae,_tlv:{encode:(t,n)=>{const{Err:e}=K;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length&1)throw new e("tlv.encode: unpadded data");const r=n.length/2,s=at(r);if(s.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?at(s.length/2|128):"";return at(t)+i+s+n},decode(t,n){const{Err:e}=K;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const s=n[r++],i=!!(s&128);let o=0;if(!i)o=s;else{const u=s&127;if(!u)throw new e("tlv.decode(long): indefinite length not supported");if(u>4)throw new e("tlv.decode(long): byte length is too big");const g=n.subarray(r,r+u);if(g.length!==u)throw new e("tlv.decode: length bytes not complete");if(g[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const a of g)o=o<<8|a;if(r+=u,o<128)throw new e("tlv.decode(long): not minimal encoding")}const c=n.subarray(r,r+o);if(c.length!==o)throw new e("tlv.decode: wrong value length");return{v:c,l:n.subarray(r+o)}}},_int:{encode(t){const{Err:n}=K;if(t<it)throw new n("integer: negative integers are not allowed");let e=at(t);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=K;if(t[0]&128)throw new n("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ht(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=K,s=$("signature",t),{v:i,l:o}=r.decode(48,s);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:c,l:u}=r.decode(2,i),{v:g,l:a}=r.decode(2,u);if(a.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(c),s:e.decode(g)}},hexFromSig(t){const{_tlv:n,_int:e}=K,r=n.encode(2,e.encode(t.r)),s=n.encode(2,e.encode(t.s)),i=r+s;return n.encode(48,i)}},it=BigInt(0),et=BigInt(1),Oe=BigInt(2),ft=BigInt(3),He=BigInt(4);function Jt(t,n,e){function r(s){const i=t.sqr(s),o=t.mul(i,s);return t.add(t.add(o,t.mul(s,n)),e)}return r}function Nt(t,n,e){const{BYTES:r}=t;function s(i){let o;if(typeof i=="bigint")o=i;else{let c=$("private key",i);if(n){if(!n.includes(c.length*2))throw new Error("invalid private key");const u=new Uint8Array(r);u.set(c,u.length-c.length),c=u}try{o=t.fromBytes(c)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof i}`)}}if(e&&(o=t.create(o)),!t.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return s}function te(t,n={}){const{Fp:e,Fn:r}=qe("weierstrass",t,n),{h:s,n:i}=t;_t(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=n;if(o&&(!e.is0(t.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function c(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function u(O,f,h){const{x:l,y:d}=f.toAffine(),w=e.toBytes(l);if(lt("isCompressed",h),h){c();const p=!e.isOdd(d);return F(ee(p),w)}else return F(Uint8Array.of(4),w,e.toBytes(d))}function g(O){ct(O);const f=e.BYTES,h=f+1,l=2*f+1,d=O.length,w=O[0],p=O.subarray(1);if(d===h&&(w===2||w===3)){const y=e.fromBytes(p);if(!e.isValid(y))throw new Error("bad point: is not on curve, wrong x");const m=x(y);let B;try{B=e.sqrt(m)}catch(N){const v=N instanceof Error?": "+N.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}c();const b=e.isOdd(B);return(w&1)===1!==b&&(B=e.neg(B)),{x:y,y:B}}else if(d===l&&w===4){const y=e.fromBytes(p.subarray(f*0,f*1)),m=e.fromBytes(p.subarray(f*1,f*2));if(!S(y,m))throw new Error("bad point: is not on curve");return{x:y,y:m}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${l}`)}const a=n.toBytes||u,E=n.fromBytes||g,x=Jt(e,t.a,t.b);function S(O,f){const h=e.sqr(f),l=x(O);return e.eql(h,l)}if(!S(t.Gx,t.Gy))throw new Error("bad curve params: generator point");const A=e.mul(e.pow(t.a,ft),He),_=e.mul(e.sqr(t.b),BigInt(27));if(e.is0(e.add(A,_)))throw new Error("bad curve params: a or b");function L(O,f,h=!1){if(!e.isValid(f)||h&&e.is0(f))throw new Error(`bad point coordinate ${O}`);return f}function C(O){if(!(O instanceof I))throw new Error("ProjectivePoint expected")}const W=At((O,f)=>{const{px:h,py:l,pz:d}=O;if(e.eql(d,e.ONE))return{x:h,y:l};const w=O.is0();f==null&&(f=w?e.ONE:e.inv(d));const p=e.mul(h,f),y=e.mul(l,f),m=e.mul(d,f);if(w)return{x:e.ZERO,y:e.ZERO};if(!e.eql(m,e.ONE))throw new Error("invZ was invalid");return{x:p,y}}),Y=At(O=>{if(O.is0()){if(n.allowInfinityPoint&&!e.is0(O.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=O.toAffine();if(!e.isValid(f)||!e.isValid(h))throw new Error("bad point: x or y not field elements");if(!S(f,h))throw new Error("bad point: equation left != right");if(!O.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Q(O,f,h,l,d){return h=new I(e.mul(h.px,O),h.py,h.pz),f=ot(l,f),h=ot(d,h),f.add(h)}class I{constructor(f,h,l){this.px=L("x",f),this.py=L("y",h,!0),this.pz=L("z",l),Object.freeze(this)}static fromAffine(f){const{x:h,y:l}=f||{};if(!f||!e.isValid(h)||!e.isValid(l))throw new Error("invalid affine point");if(f instanceof I)throw new Error("projective point not allowed");return e.is0(h)&&e.is0(l)?I.ZERO:new I(h,l,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){return ve(I,"pz",f)}static fromBytes(f){return ct(f),I.fromHex(f)}static fromHex(f){const h=I.fromAffine(E($("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){const h=Nt(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return I.BASE.multiply(h(f))}static msm(f,h){return Ne(I,r,f,h)}precompute(f=8,h=!0){return V.setWindowSize(this,f),h||this.multiply(ft),this}_setWindowSize(f){this.precompute(f)}assertValidity(){Y(this)}hasEvenY(){const{y:f}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(f)}equals(f){C(f);const{px:h,py:l,pz:d}=this,{px:w,py:p,pz:y}=f,m=e.eql(e.mul(h,y),e.mul(w,d)),B=e.eql(e.mul(l,y),e.mul(p,d));return m&&B}negate(){return new I(this.px,e.neg(this.py),this.pz)}double(){const{a:f,b:h}=t,l=e.mul(h,ft),{px:d,py:w,pz:p}=this;let y=e.ZERO,m=e.ZERO,B=e.ZERO,b=e.mul(d,d),H=e.mul(w,w),N=e.mul(p,p),v=e.mul(d,w);return v=e.add(v,v),B=e.mul(d,p),B=e.add(B,B),y=e.mul(f,B),m=e.mul(l,N),m=e.add(y,m),y=e.sub(H,m),m=e.add(H,m),m=e.mul(y,m),y=e.mul(v,y),B=e.mul(l,B),N=e.mul(f,N),v=e.sub(b,N),v=e.mul(f,v),v=e.add(v,B),B=e.add(b,b),b=e.add(B,b),b=e.add(b,N),b=e.mul(b,v),m=e.add(m,b),N=e.mul(w,p),N=e.add(N,N),b=e.mul(N,v),y=e.sub(y,b),B=e.mul(N,H),B=e.add(B,B),B=e.add(B,B),new I(y,m,B)}add(f){C(f);const{px:h,py:l,pz:d}=this,{px:w,py:p,pz:y}=f;let m=e.ZERO,B=e.ZERO,b=e.ZERO;const H=t.a,N=e.mul(t.b,ft);let v=e.mul(h,w),R=e.mul(l,p),z=e.mul(d,y),T=e.add(h,l),q=e.add(w,p);T=e.mul(T,q),q=e.add(v,R),T=e.sub(T,q),q=e.add(h,d);let j=e.add(w,y);return q=e.mul(q,j),j=e.add(v,z),q=e.sub(q,j),j=e.add(l,d),m=e.add(p,y),j=e.mul(j,m),m=e.add(R,z),j=e.sub(j,m),b=e.mul(H,q),m=e.mul(N,z),b=e.add(m,b),m=e.sub(R,b),b=e.add(R,b),B=e.mul(m,b),R=e.add(v,v),R=e.add(R,v),z=e.mul(H,z),q=e.mul(N,q),R=e.add(R,z),z=e.sub(v,z),z=e.mul(H,z),q=e.add(q,z),v=e.mul(R,q),B=e.add(B,v),v=e.mul(j,q),m=e.mul(T,m),m=e.sub(m,v),v=e.mul(T,R),b=e.mul(j,b),b=e.add(b,v),new I(m,B,b)}subtract(f){return this.add(f.negate())}is0(){return this.equals(I.ZERO)}multiply(f){const{endo:h}=n;if(!r.isValidNot0(f))throw new Error("invalid scalar: out of range");let l,d;const w=p=>V.wNAFCached(this,p,I.normalizeZ);if(h){const{k1neg:p,k1:y,k2neg:m,k2:B}=h.splitScalar(f),{p:b,f:H}=w(y),{p:N,f:v}=w(B);d=H.add(v),l=Q(h.beta,b,N,p,m)}else{const{p,f:y}=w(f);l=p,d=y}return I.normalizeZ([l,d])[0]}multiplyUnsafe(f){const{endo:h}=n,l=this;if(!r.isValid(f))throw new Error("invalid scalar: out of range");if(f===it||l.is0())return I.ZERO;if(f===et)return l;if(V.hasPrecomputes(this))return this.multiply(f);if(h){const{k1neg:d,k1:w,k2neg:p,k2:y}=h.splitScalar(f),{p1:m,p2:B}=_e(I,l,w,y);return Q(h.beta,m,B,d,p)}else return V.wNAFCachedUnsafe(l,f)}multiplyAndAddUnsafe(f,h,l){const d=this.multiplyUnsafe(h).add(f.multiplyUnsafe(l));return d.is0()?void 0:d}toAffine(f){return W(this,f)}isTorsionFree(){const{isTorsionFree:f}=n;return s===et?!0:f?f(I,this):V.wNAFCachedUnsafe(this,i).is0()}clearCofactor(){const{clearCofactor:f}=n;return s===et?this:f?f(I,this):this.multiplyUnsafe(s)}toBytes(f=!0){return lt("isCompressed",f),this.assertValidity(),a(I,this,f)}toRawBytes(f=!0){return this.toBytes(f)}toHex(f=!0){return st(this.toBytes(f))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}I.BASE=new I(t.Gx,t.Gy,e.ONE),I.ZERO=new I(e.ZERO,e.ONE,e.ZERO),I.Fp=e,I.Fn=r;const D=r.BITS,V=Ie(I,n.endo?Math.ceil(D/2):D);return I}function De(t){const{CURVE:n,curveOpts:e}=ne(t),r=te(n,e);return Le(t,r)}function ee(t){return Uint8Array.of(t?2:3)}function Re(t,n,e={}){_t(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||fe,s=n.hmac||((l,...d)=>Kt(n.hash,l,F(...d))),{Fp:i,Fn:o}=t,{ORDER:c,BITS:u}=o;function g(l){const d=c>>et;return l>d}function a(l){return g(l)?o.neg(l):l}function E(l,d){if(!o.isValidNot0(d))throw new Error(`invalid signature ${l}: out of range 1..CURVE.n`)}class x{constructor(d,w,p){E("r",d),E("s",w),this.r=d,this.s=w,p!=null&&(this.recovery=p),Object.freeze(this)}static fromCompact(d){const w=o.BYTES,p=$("compactSignature",d,w*2);return new x(o.fromBytes(p.subarray(0,w)),o.fromBytes(p.subarray(w,w*2)))}static fromDER(d){const{r:w,s:p}=K.toSig($("DER",d));return new x(w,p)}assertValidity(){}addRecoveryBit(d){return new x(this.r,this.s,d)}recoverPublicKey(d){const w=i.ORDER,{r:p,s:y,recovery:m}=this;if(m==null||![0,1,2,3].includes(m))throw new Error("recovery id invalid");if(c*Oe<w&&m>1)throw new Error("recovery id is ambiguous for h>1 curve");const b=m===2||m===3?p+c:p;if(!i.isValid(b))throw new Error("recovery id 2 or 3 invalid");const H=i.toBytes(b),N=t.fromHex(F(ee((m&1)===0),H)),v=o.inv(b),R=Y($("msgHash",d)),z=o.create(-R*v),T=o.create(y*v),q=t.BASE.multiplyUnsafe(z).add(N.multiplyUnsafe(T));if(q.is0())throw new Error("point at infinify");return q.assertValidity(),q}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,o.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return F(o.toBytes(this.r),o.toBytes(this.s));if(d==="der")return xt(K.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return st(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return st(this.toBytes("compact"))}}const S=Nt(o,e.allowedPrivateKeyLengths,e.wrapPrivateKey),A={isValidPrivateKey(l){try{return S(l),!0}catch{return!1}},normPrivateKeyToScalar:S,randomPrivateKey:()=>{const l=c;return Be(r(Xt(l)),l)},precompute(l=8,d=t.BASE){return d.precompute(l,!1)}};function _(l,d=!0){return t.fromPrivateKey(l).toBytes(d)}function L(l){if(typeof l=="bigint")return!1;if(l instanceof t)return!0;const w=$("key",l).length,p=i.BYTES,y=p+1,m=2*p+1;if(!(e.allowedPrivateKeyLengths||o.BYTES===y))return w===y||w===m}function C(l,d,w=!0){if(L(l)===!0)throw new Error("first arg must be private key");if(L(d)===!1)throw new Error("second arg must be public key");return t.fromHex(d).multiply(S(l)).toBytes(w)}const W=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const d=ht(l),w=l.length*8-u;return w>0?d>>BigInt(w):d},Y=n.bits2int_modN||function(l){return o.create(W(l))},Q=wt(u);function I(l){return ue("num < 2^"+u,l,it,Q),o.toBytes(l)}function D(l,d,w=V){if(["recovered","canonical"].some(T=>T in w))throw new Error("sign() legacy options not supported");const{hash:p}=n;let{lowS:y,prehash:m,extraEntropy:B}=w;y==null&&(y=!0),l=$("msgHash",l),Zt(w),m&&(l=$("prehashed msgHash",p(l)));const b=Y(l),H=S(d),N=[I(H),I(b)];if(B!=null&&B!==!1){const T=B===!0?r(i.BYTES):B;N.push($("extraEntropy",T))}const v=F(...N),R=b;function z(T){const q=W(T);if(!o.isValidNot0(q))return;const j=o.inv(q),rt=t.BASE.multiply(q).toAffine(),J=o.create(rt.x);if(J===it)return;const P=o.create(j*o.create(R+J*H));if(P===it)return;let yt=(rt.x===J?0:2)|Number(rt.y&et),tt=P;return y&&g(P)&&(tt=a(P),yt^=1),new x(J,tt,yt)}return{seed:v,k2sig:z}}const V={lowS:n.lowS,prehash:!1},O={lowS:n.lowS,prehash:!1};function f(l,d,w=V){const{seed:p,k2sig:y}=D(l,d,w);return de(n.hash.outputLen,o.BYTES,s)(p,y)}t.BASE.precompute(8);function h(l,d,w,p=O){const y=l;d=$("msgHash",d),w=$("publicKey",w),Zt(p);const{lowS:m,prehash:B,format:b}=p;if("strict"in p)throw new Error("options.strict was renamed to lowS");if(b!==void 0&&!["compact","der","js"].includes(b))throw new Error('format must be "compact", "der" or "js"');const H=typeof y=="string"||jt(y),N=!H&&!b&&typeof y=="object"&&y!==null&&typeof y.r=="bigint"&&typeof y.s=="bigint";if(!H&&!N)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let v,R;try{if(N)if(b===void 0||b==="js")v=new x(y.r,y.s);else throw new Error("invalid format");if(H){try{b!=="compact"&&(v=x.fromDER(y))}catch(tt){if(!(tt instanceof K.Err))throw tt}!v&&b!=="der"&&(v=x.fromCompact(y))}R=t.fromHex(w)}catch{return!1}if(!v||m&&v.hasHighS())return!1;B&&(d=n.hash(d));const{r:z,s:T}=v,q=Y(d),j=o.inv(T),rt=o.create(q*j),J=o.create(z*j),P=t.BASE.multiplyUnsafe(rt).add(R.multiplyUnsafe(J));return P.is0()?!1:o.create(P.x)===z}return Object.freeze({getPublicKey:_,getSharedSecret:C,sign:f,verify:h,utils:A,Point:t,Signature:x})}function ne(t){const n={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},e=t.Fp,r=gt(n.n,t.nBitLength),s={Fp:e,Fn:r,allowedPrivateKeyLengths:t.allowedPrivateKeyLengths,allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,wrapPrivateKey:t.wrapPrivateKey,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:n,curveOpts:s}}function ze(t){const{CURVE:n,curveOpts:e}=ne(t),r={hash:t.hash,hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:n,curveOpts:e,ecdsaOpts:r}}function Le(t,n){const{Fp:e,Fn:r}=n;function s(c){return Mt(c,et,r.ORDER)}const i=Jt(e,t.a,t.b),o=Nt(r,t.allowedPrivateKeyLengths,t.wrapPrivateKey);return Object.assign({},{CURVE:t,Point:n,ProjectivePoint:n,normPrivateKeyToScalar:o,weierstrassEquation:i,isWithinCurveOrder:s})}function Ze(t,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:t})}function Te(t){const{CURVE:n,curveOpts:e,ecdsaOpts:r}=ze(t),s=te(n,e),i=Re(s,r,e);return Ze(t,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function je(t,n){const e=r=>Te({...t,hash:r});return{...e(n),create:e}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const ke=BigInt(1),Bt=BigInt(2),Tt=(t,n)=>(t+n/Bt)/n;function Ue(t){const n=dt.p,e=BigInt(3),r=BigInt(6),s=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),u=BigInt(88),g=t*t*t%n,a=g*g*t%n,E=M(a,e,n)*a%n,x=M(E,e,n)*a%n,S=M(x,Bt,n)*g%n,A=M(S,s,n)*S%n,_=M(A,i,n)*A%n,L=M(_,c,n)*_%n,C=M(L,u,n)*L%n,W=M(C,c,n)*_%n,Y=M(W,e,n)*a%n,Q=M(Y,o,n)*A%n,I=M(Q,r,n)*g%n,D=M(I,Bt,n);if(!vt.eql(vt.sqr(D),t))throw new Error("Cannot find square root");return D}const vt=gt(dt.p,void 0,void 0,{sqrt:Ue}),Ce=je({...dt,Fp:vt,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=dt.n,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ke*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,o=BigInt("0x100000000000000000000000000000000"),c=Tt(i*t,n),u=Tt(-r*t,n);let g=U(t-c*e-u*s,n),a=U(-c*r-u*i,n);const E=g>o,x=a>o;if(E&&(g=n-g),x&&(a=n-a),g>o||a>o)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:E,k1:g,k2neg:x,k2:a}}}},ce),Pe=Object.freeze(Object.defineProperty({__proto__:null,secp256k1:Ce},Symbol.toStringTag,{value:"Module"}));export{$e as A,Te as B,Pe as C,gt as F,_t as _,qe as a,ht as b,lt as c,At as d,ue as e,$ as f,Ut as g,Ct as h,Ke as i,M as j,Ye as k,Kt as l,U as m,ve as n,De as o,Ne as p,Xt as q,Be as r,Ce as s,wt as t,le as u,Ft as v,Ie as w,be as x,Ve as y,Ht as z};
